/******************************************************************************
Finite State Machine
Project: fsm.dot
Description: bms_lv

Generated by gv_fsm ruby gem, see https://rubygems.org/gems/gv_fsm
gv_fsm version 0.3.4
Generation date: 2024-01-23 11:59:31 +0100
Generated from: fsm.dot
The finite state machine has:
  6 states
  7 transition functions
******************************************************************************/

#include "bms_fsm.h"
#include "bms_lv_config.h"
#include <stdint.h>

void lv_error_init(void);
void error_routine(void);
bool error_get_fatal(void);

void adc_routine_start(void);
void monitor_init(void);
void gpio_extender_init(void);
void adc_vrefint_calibration(void);
int can_start();

void adc_routine(void);
void can_routine(void);
void gpio_extender_routine(void);
void monitor_routine(void);
bool check_total_voltage(void);
void all_measurements_check(void);

int set_discharge(int state);
int set_rfe_frg(int state);
void set_relay(uint8_t status);
int set_led(int led1, int led2, int led3);
void radiator_init();
void dac_pump_init();

void bms_lv_routine(void) {
  error_routine();
  adc_routine();
  can_routine();
  gpio_extender_routine();
  monitor_routine();
  all_measurements_check();
}

uint8_t inverter_state = 0;

// SEARCH FOR Your Code Here FOR CODE INSERTION POINTS!

// GLOBALS
// State human-readable names
const char *state_names[] = {"init", "idle",     "error",
                             "tson", "flashing", "run"};

// List of state functions
state_func_t *const state_table[NUM_STATES] = {
    do_init,     // in state init
    do_idle,     // in state idle
    do_error,    // in state error
    do_tson,     // in state tson
    do_flashing, // in state flashing
    do_run,      // in state run
};

// Table of transition functions
transition_func_t *const transition_table[NUM_STATES][NUM_STATES] = {
    /* states:      init            , idle            , error           , tson
       , flashing        , run              */
    /* init     */ {NULL, init_to_idle, to_error, NULL, NULL, NULL},
    /* idle     */ {NULL, NULL, to_error, idle_to_tson, idle_to_flashing, NULL},
    /* error    */ {NULL, NULL, NULL, NULL, NULL, NULL},
    /* tson     */ {NULL, tson_to_idle, NULL, NULL, NULL, tson_to_run},
    /* flashing */ {NULL, NULL, to_error, NULL, NULL, NULL},
    /* run      */ {NULL, run_to_idle, to_error, NULL, NULL, NULL},
};

/*  ____  _        _
 * / ___|| |_ __ _| |_ ___
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/
 * |____/ \__\__,_|\__\___|
 *
 *   __                  _   _
 *  / _|_   _ _ __   ___| |_(_) ___  _ __  ___
 * | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
 * |  _| |_| | | | | (__| |_| | (_) | | | \__ \
 * |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
 */

// Function to be executed in state init
// valid return states: STATE_IDLE, STATE_ERROR
state_t do_init(state_data_t *data) {
  state_t next_state = STATE_IDLE;

  /* Your Code Here */

  // cooling OFF
  radiator_init();
  dac_pump_init();
  // discharge ON
  set_discharge(1);
  // rfe/frg OFF
  set_rfe_frg(0);

  // check error codes
  lv_error_init();
  adc_routine_start();
  adc_vrefint_calibration();
  monitor_init();
  gpio_extender_init();
  can_start();

  monitor_routine();
  error_routine();

  if (error_get_fatal() || !check_total_voltage()) {
    next_state = STATE_ERROR;
  }

  switch (next_state) {
  case STATE_IDLE:
  case STATE_ERROR:
    break;
  default:
    next_state = NO_CHANGE;
  }

  return next_state;
}

// Function to be executed in state idle
// valid return states: NO_CHANGE, STATE_IDLE, STATE_TSON, STATE_FLASHING,
// STATE_ERROR
state_t do_idle(state_data_t *data) {
  state_t next_state = NO_CHANGE;

  // cooling no change
  // discharge ON
  set_discharge(1);
  // rfe/frg OFF
  set_rfe_frg(0);

  /* Your Code Here */
  bms_lv_routine();

  // until car_status == IDLE

  if (error_get_fatal()) {
    next_state = STATE_ERROR;
  }

  switch (next_state) {
  case NO_CHANGE:
  case STATE_IDLE:
  case STATE_TSON:
  case STATE_FLASHING:
  case STATE_ERROR:
    break;
  default:
    next_state = NO_CHANGE;
  }

  return next_state;
}

// Function to be executed in state error
// valid return states: NO_CHANGE
state_t do_error(state_data_t *data) {
  state_t next_state = NO_CHANGE;

  // cooling OFF
  // discharge ON
  set_discharge(1);
  // rfe/frg OFF
  set_rfe_frg(0);

  /* Your Code Here */
  // TODO: error code check, [send it via can/write to flash], shutdown
  set_relay(0);

  switch (next_state) {
  case NO_CHANGE:
    break;
  default:
    next_state = NO_CHANGE;
  }

  return next_state;
}

// Function to be executed in state tson
// valid return states: NO_CHANGE, STATE_IDLE, STATE_TSON, STATE_RUN
state_t do_tson(state_data_t *data) {
  state_t next_state = NO_CHANGE;

  // cooling no change
  // set discharge OFF
  set_discharge(0);
  // set rfe/frg OFF
  set_rfe_frg(0);
  // until car_status == {...}

  /* Your Code Here */
  bms_lv_routine();

  // until car_status == {...}
  // car_status -> drive -> run
  // car_status -> idle -> idle

  switch (next_state) {
  case NO_CHANGE:
  case STATE_IDLE:
  case STATE_TSON:
  case STATE_RUN:
    break;
  default:
    next_state = NO_CHANGE;
  }

  return next_state;
}

// Function to be executed in state flashing
// valid return states: STATE_ERROR
state_t do_flashing(state_data_t *data) {
  state_t next_state = STATE_ERROR;

  // cooling no change
  // set discharge ON
  set_discharge(1);
  // set rfe/frg OFF
  set_rfe_frg(0);
  // SET TIME_SET ON
  set_time_set(1);
  HAL_Delay(
      16); // 15.51ms has been calculeted as charge time for che condensator
  set_time_set(0);

  /* Your Code Here */

  switch (next_state) {
  case STATE_ERROR:
    break;
  default:
    next_state = NO_CHANGE;
  }

  return next_state;
}

// Function to be executed in state run
// valid return states: NO_CHANGE, STATE_IDLE, STATE_RUN, STATE_ERROR
state_t do_run(state_data_t *data) {
  state_t next_state = NO_CHANGE;

  // activate automatic cooling
  // set discharge OFF
  set_discharge(1);
  // set rfe/frg ON
  set_rfe_frg(1);

  /* Your Code Here */
  bms_lv_routine();

  // until car_status == run

  switch (next_state) {
  case NO_CHANGE:
  case STATE_IDLE:
  case STATE_RUN:
  case STATE_ERROR:
    break;
  default:
    next_state = NO_CHANGE;
  }

  return next_state;
}

/*  _____                    _ _   _
 * |_   _| __ __ _ _ __  ___(_) |_(_) ___  _ __
 *   | || '__/ _` | '_ \/ __| | __| |/ _ \| '_ \
 *   | || | | (_| | | | \__ \ | |_| | (_) | | | |
 *   |_||_|  \__,_|_| |_|___/_|\__|_|\___/|_| |_|
 *
 *   __                  _   _
 *  / _|_   _ _ __   ___| |_(_) ___  _ __  ___
 * | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
 * |  _| |_| | | | | (__| |_| | (_) | | | \__ \
 * |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
 */

// This function is called in 1 transition:
// 1. from init to idle
void init_to_idle(state_data_t *data) { /* Your Code Here */
  set_relay(1);
  set_led(1, 0, 0);
}

// This function is called in 4 transitions:
// 1. from init to error
// 2. from idle to error
// 3. from run to error
// 4. from flashing to error
void to_error(state_data_t *data) { /* Your Code Here */
  set_led(0, 0, 0);
}

// This function is called in 1 transition:
// 1. from idle to tson
void idle_to_tson(state_data_t *data) { /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from idle to flashing
void idle_to_flashing(state_data_t *data) { /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from tson to idle
void tson_to_idle(state_data_t *data) { /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from tson to run
void tson_to_run(state_data_t *data) { /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from run to idle
void run_to_idle(state_data_t *data) { /* Your Code Here */
}

/*  ____  _        _
 * / ___|| |_ __ _| |_ ___
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/
 * |____/ \__\__,_|\__\___|
 *
 *
 *  _ __ ___   __ _ _ __   __ _  __ _  ___ _ __
 * | '_ ` _ \ / _` | '_ \ / _` |/ _` |/ _ \ '__|
 * | | | | | | (_| | | | | (_| | (_| |  __/ |
 * |_| |_| |_|\__,_|_| |_|\__,_|\__, |\___|_|
 *                              |___/
 */

state_t run_state(state_t cur_state, state_data_t *data) {
  state_t new_state = state_table[cur_state](data);
  if (new_state == NO_CHANGE)
    new_state = cur_state;
  transition_func_t *transition = transition_table[cur_state][new_state];
  if (transition)
    transition(data);
  return new_state;
};

#ifdef TEST_MAIN
#include <unistd.h>
int main() {
  state_t cur_state = STATE_INIT;
  do {
    cur_state = run_state(cur_state, NULL);
    sleep(1);
  } while (cur_state != STATE_ERROR);
  run_state(cur_state, NULL);
  return 0;
}
#endif

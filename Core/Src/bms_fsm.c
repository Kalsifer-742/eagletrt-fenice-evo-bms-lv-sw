/******************************************************************************
Finite State Machine
Project: fsm.dot
Description: bms_lv

Generated by gv_fsm ruby gem, see https://rubygems.org/gems/gv_fsm
gv_fsm version 0.3.4
Generation date: 2023-10-24 15:55:04 +0200
Generated from: fsm.dot
The finite state machine has:
  8 states
  9 transition functions
******************************************************************************/

#include "bms_fsm.h"

// SEARCH FOR Your Code Here FOR CODE INSERTION POINTS!

// GLOBALS
// State human-readable names
const char *state_names[] = {"init", "idle", "error", "init_run", "flashing", "charging", "run", "deinit_run"};

// List of state functions
state_func_t *const state_table[NUM_STATES] = {
  do_init,       // in state init
  do_idle,       // in state idle
  do_error,      // in state error
  do_init_run,   // in state init_run
  do_flashing,   // in state flashing
  do_charging,   // in state charging
  do_run,        // in state run
  do_deinit_run, // in state deinit_run
};

// Table of transition functions
transition_func_t *const transition_table[NUM_STATES][NUM_STATES] = {
  /* states:        init              , idle              , error             , init_run          , flashing          , charging          , run               , deinit_run         */
  /* init       */ {NULL              , init_to_idle      , to_error          , NULL              , NULL              , NULL              , NULL              , NULL              }, 
  /* idle       */ {NULL              , NULL              , to_error          , idle_to_init_run  , idle_to_flashing  , idle_to_charging  , NULL              , NULL              }, 
  /* error      */ {NULL              , NULL              , NULL              , NULL              , NULL              , NULL              , NULL              , NULL              }, 
  /* init_run   */ {NULL              , NULL              , to_error          , NULL              , NULL              , NULL              , init_run_to_run   , NULL              }, 
  /* flashing   */ {NULL              , NULL              , to_error          , NULL              , NULL              , NULL              , NULL              , NULL              }, 
  /* charging   */ {NULL              , charging_to_idle  , to_error          , NULL              , NULL              , NULL              , NULL              , NULL              }, 
  /* run        */ {NULL              , NULL              , to_error          , NULL              , NULL              , NULL              , NULL              , run_to_deinit_run }, 
  /* deinit_run */ {NULL              , deinit_run_to_idle, to_error          , NULL              , NULL              , NULL              , NULL              , NULL              }, 
};

/*  ____  _        _       
 * / ___|| |_ __ _| |_ ___ 
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/
 * |____/ \__\__,_|\__\___|
 *                         
 *   __                  _   _                 
 *  / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
 * | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
 * |  _| |_| | | | | (__| |_| | (_) | | | \__ \
 * |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
 */                                             

// Function to be executed in state init
// valid return states: STATE_IDLE, STATE_ERROR
state_t do_init(state_data_t *data) {
  state_t next_state = STATE_IDLE;
  
  /* Your Code Here */

  switch (next_state) {
    case STATE_IDLE:
    case STATE_ERROR:
      break;
    default:
      next_state = NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state idle
// valid return states: NO_CHANGE, STATE_IDLE, STATE_INIT_RUN, STATE_FLASHING, STATE_CHARGING, STATE_ERROR
state_t do_idle(state_data_t *data) {
  state_t next_state = NO_CHANGE;
  
  /* Your Code Here */
  
  switch (next_state) {
    case NO_CHANGE:
    case STATE_IDLE:
    case STATE_INIT_RUN:
    case STATE_FLASHING:
    case STATE_CHARGING:
    case STATE_ERROR:
      break;
    default:
      next_state = NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state error
// valid return states: NO_CHANGE
state_t do_error(state_data_t *data) {
  state_t next_state = NO_CHANGE;
  
  /* Your Code Here */
  
  switch (next_state) {
    case NO_CHANGE:
      break;
    default:
      next_state = NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state init_run
// valid return states: STATE_RUN, STATE_ERROR
state_t do_init_run(state_data_t *data) {
  state_t next_state = STATE_RUN;
  
  /* Your Code Here */
  
  switch (next_state) {
    case STATE_RUN:
    case STATE_ERROR:
      break;
    default:
      next_state = NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state flashing
// valid return states: STATE_ERROR
state_t do_flashing(state_data_t *data) {
  state_t next_state = STATE_ERROR;
  
  /* Your Code Here */
  
  switch (next_state) {
    case STATE_ERROR:
      break;
    default:
      next_state = NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state charging
// valid return states: NO_CHANGE, STATE_IDLE, STATE_CHARGING, STATE_ERROR
state_t do_charging(state_data_t *data) {
  state_t next_state = NO_CHANGE;
  
  /* Your Code Here */
  
  switch (next_state) {
    case NO_CHANGE:
    case STATE_IDLE:
    case STATE_CHARGING:
    case STATE_ERROR:
      break;
    default:
      next_state = NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state run
// valid return states: NO_CHANGE, STATE_RUN, STATE_DEINIT_RUN, STATE_ERROR
state_t do_run(state_data_t *data) {
  state_t next_state = NO_CHANGE;
  
  /* Your Code Here */
  
  switch (next_state) {
    case NO_CHANGE:
    case STATE_RUN:
    case STATE_DEINIT_RUN:
    case STATE_ERROR:
      break;
    default:
      next_state = NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state deinit_run
// valid return states: STATE_IDLE, STATE_ERROR
state_t do_deinit_run(state_data_t *data) {
  state_t next_state = STATE_IDLE;
  
  /* Your Code Here */
  
  switch (next_state) {
    case STATE_IDLE:
    case STATE_ERROR:
      break;
    default:
      next_state = NO_CHANGE;
  }
  
  return next_state;
}


/*  _____                    _ _   _              
 * |_   _| __ __ _ _ __  ___(_) |_(_) ___  _ __   
 *   | || '__/ _` | '_ \/ __| | __| |/ _ \| '_ \
 *   | || | | (_| | | | \__ \ | |_| | (_) | | | | 
 *   |_||_|  \__,_|_| |_|___/_|\__|_|\___/|_| |_| 
 *                                                
 *   __                  _   _                 
 *  / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
 * | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
 * |  _| |_| | | | | (__| |_| | (_) | | | \__ \
 * |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
 */    
                                         
// This function is called in 1 transition:
// 1. from init to idle
void init_to_idle(state_data_t *data) {
  /* Your Code Here */
}

// This function is called in 7 transitions:
// 1. from init to error
// 2. from idle to error
// 3. from init_run to error
// 4. from run to error
// 5. from deinit_run to error
// 6. from flashing to error
// 7. from charging to error
void to_error(state_data_t *data) {
  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from idle to init_run
void idle_to_init_run(state_data_t *data) {
  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from idle to flashing
void idle_to_flashing(state_data_t *data) {
  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from idle to charging
void idle_to_charging(state_data_t *data) {
  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from init_run to run
void init_run_to_run(state_data_t *data) {
  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from run to deinit_run
void run_to_deinit_run(state_data_t *data) {
  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from deinit_run to idle
void deinit_run_to_idle(state_data_t *data) {
  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from charging to idle
void charging_to_idle(state_data_t *data) {
  /* Your Code Here */
}


/*  ____  _        _        
 * / ___|| |_ __ _| |_ ___  
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/ 
 * |____/ \__\__,_|\__\___| 
 *                          
 *                                              
 *  _ __ ___   __ _ _ __   __ _  __ _  ___ _ __ 
 * | '_ ` _ \ / _` | '_ \ / _` |/ _` |/ _ \ '__|
 * | | | | | | (_| | | | | (_| | (_| |  __/ |   
 * |_| |_| |_|\__,_|_| |_|\__,_|\__, |\___|_|   
 *                              |___/           
 */

state_t run_state(state_t cur_state, state_data_t *data) {
  state_t new_state = state_table[cur_state](data);
  if (new_state == NO_CHANGE) new_state = cur_state;
  transition_func_t *transition = transition_table[cur_state][new_state];
  if (transition)
    transition(data);
  return new_state;
};

#ifdef TEST_MAIN
#include <unistd.h>
int main() {
  state_t cur_state = STATE_INIT;
  do {
    cur_state = run_state(cur_state, NULL);
    sleep(1);
  } while (cur_state != STATE_ERROR);
  run_state(cur_state, NULL);
  return 0;
}
#endif
